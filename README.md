---
# 目录

<!-- 目录 -->
- [1. 一维数组：`arr == &arr[0]` 的设计意图](#1-一维数组arr--arr0-的设计意图)
  - [1.1 历史与硬件友好性](#11-历史与硬件友好性)
  - [1.2 一致性原则](#12-一致性原则)
  - [1.3 语言设计的逻辑](#13-语言设计的逻辑)
  - [1.4 例外情况](#14-例外情况)
  - [1.5 示例验证](#15-示例验证)
  - [1.6 小结](#16-小结)
- [2. 二维数组：`&arr` 及其他地址含义](#2-二维数组arr-及其他地址含义)
  - [2.1 `&arr` 的含义](#21-arr-的含义)
  - [2.2 代码演示](#22-代码演示)
  - [2.3 区别总结](#23-区别总结)
  - [2.4 正确存储 `&arr` 的方式](#24-正确存储-arr-的方式)
- [3. 函数指针学习整理](#3-函数指针学习整理)
  - [3.1 基础概念](#31-基础概念)
  - [3.2 函数指针的核心价值](#32-函数指针-核心价值)
  - [3.3 应用示例与说明](#33-应用示例与说明)
    - [3.3.1 回调函数Callback](#331-回调函数callback)
    - [3.3.2 函数数组-菜单调用](#332-函数数组-菜单调用)
    - [3.3.3 状态机State-Machine](#333-状态机state-machine)
    - [3.3.4 结构体-函数指针-模拟虚函数](#334-结构体-函数指针-模拟虚函数)
  - [3.4 拓展场景](#34-拓展场景)
  - [3.5 总结](#35-总结)

2. [函数指针学习整理](#函数指针学习整理)

   1. [基础概念](#1-函数指针-基础概念)
   2. [函数指针的核心价值](#2-函数指针-核心价值)
   3. [应用示例与说明](#3-应用示例与说明)

      1. [回调函数Callback](#31-回调函数callback)
      2. [函数数组-菜单调用](#32-函数数组-菜单调用)
      3. [状态机State-Machine](#33-状态机state-machine)
      4. [结构体-函数指针-模拟虚函数](#34-结构体-函数指针-模拟虚函数)
   4. [拓展场景](#4-拓展场景)
   5. [总结](#5-函数指针-总结)

---

# C语言数组与指针地址体系总结
通过，问题一：arr[3] = {1,2,3};为什么要设计“arr == &arr[0]”，理解一维数组

通过问题二：二维数组中，arr[2][3],&arr 的含义，理解二维数组


在C语言中，`arr == &arr[0]` 这种设计是语言的核心特性之一，它体现了数组名在大多数情况下会退化为指向数组首元素的指针。这种设计有以下几个关键原因和逻辑：

---

### 1. **历史与硬件友好性**
C语言的设计深受早期计算机体系结构（如指针和内存直接操作）的影响。数组名退化为指针的特性使得：
   - **代码更高效**：直接通过指针算术（如`*(arr + i)`）访问元素，无需额外的解引用步骤，编译后的机器码更接近底层硬件操作（如基址+偏移寻址）。
   - **与汇编语言习惯一致**：早期程序员常用指针遍历数组，这种设计简化了编译器实现。

---

### 2. **一致性原则**
   - **指针算术的便利性**：`arr[i]` 本质上等价于 `*(arr + i)`。若 `arr` 不退化为指针，这种语法将无法直接使用。
   - **函数参数传递**：将数组传递给函数时（如 `func(arr)`），实际传递的是指针而非整个数组。若 `arr` 不退化为指针，需额外语法处理，违背C的简洁哲学。

---

### 3. **语言设计的逻辑**
   - **数组名是“常量指针”**：`arr` 的类型是 `int[3]`，但在表达式中（除了 `sizeof(arr)` 或 `&arr`），它自动转换为 `int*` 类型，指向首元素。
   - `&arr[0]` 的含义：
     - `arr[0]` 是首元素（值 `1`）。
     - `&arr[0]` 是取该元素的地址，类型为 `int*`，与 `arr` 退化后的类型一致。

---

### 4. **例外情况**
   - `sizeof(arr)`：此时 `arr` 代表整个数组，返回数组总字节数（如 `3 * sizeof(int)`）。
   - `&arr`：取数组地址，类型是 `int(*)[3]`（指向整个数组的指针），而非 `int*`。

---

### 示例验证
```c
int arr[3] = {1, 2, 3};
printf("%p == %p\n", (void*)arr, (void*)&arr[0]); // 输出相同地址
printf("%p != %p\n", (void*)(arr + 1), (void*)(&arr + 1)); // 偏移量不同
```

---

### 为什么这样设计？
- **简化语法**：避免为数组和指针设计两套操作规则。
- **性能优先**：直接映射到硬件寻址模式，减少运行时开销。
- **向后兼容**：早期C代码依赖此特性，改变会破坏现有程序。

这种设计虽可能导致初学者困惑（如数组名非“真正的指针”），但它是C语言高效性和灵活性的基石之一。
这个问题问得很关键 👌，咱们就把 `&arr` 和其他几种地址对比一下。

假设代码：

```c
int arr[2][3] = {{1,2,3},{4,5,6}};
```

---

## 1. `&arr` 的含义

* `arr` 的类型是 `int [2][3]`。
* `&arr` 的类型是 **“指向一个二维数组的指针”**，即 `int (*)[2][3]`。
* 它的值就是数组整体的起始地址。

👉 直观地说：

* `arr`（在表达式里）会衰减为 `int (*)[3]`，指向**第一行**。
* `&arr` 表示**整个 2×3 数组的地址**。

---

## 2. 代码演示

```c
#include <stdio.h>

int main() {
    int arr[2][3] = {{1,2,3},{4,5,6}};

    printf("arr       = %p\n", arr);       // 类型: int (*)[3]
    printf("&arr      = %p\n", &arr);      // 类型: int (*)[2][3]
    printf("arr[0]    = %p\n", arr[0]);    // 类型: int*
    printf("&arr[0][0]= %p\n", &arr[0][0]);// 类型: int*

    return 0;
}
```

输出结果（数值一样，但**类型不同**）：

```
arr       = 0x7ffee48d13a0
&arr      = 0x7ffee48d13a0
arr[0]    = 0x7ffee48d13a0
&arr[0][0]= 0x7ffee48d13a0
```

---

## 3. 区别总结

* `arr` → **指向第一行**，类型 `int (*)[3]`。
* `&arr` → **指向整个二维数组**，类型 `int (*)[2][3]`。
* `arr[0]` → **指向首元素**，类型 `int*`。
* `&arr[0][0]` → **指向具体的第一个 int**，类型 `int*`。

---

✅ 所以 **存储 `&arr` 的地址**，应该用：

```c
int (*p)[2][3] = &arr;
```


---
# -_-
学习嵌入式的一些问答记录
现在我学会了变量和指针，一维数组和二维数组的指针，现在我能学函数指针吗？

可以的 👍
你现在已经学会了变量、指针和数组的指针，其实这些都是 理解函数指针的基础。

PS:对我而言，函数指针就是将原来需要一个个is-else来做判断做选择的事情，变成了像数组一样，通过地址（下标）直接调用，省去了做判断的功夫，修改起来代码量更少，理解之后也更直观，本质就是对if-else的简化

# 函数指针学习整理

## 1-函数指针-基础概念

* 函数指针就是存储函数地址的指针
* 写法示例：

```c
int (*fp)(int,int);   // 指向返回 int、参数为 (int,int) 的函数
fp = add;             // 指向函数 add
int result = fp(2,3); // 调用函数
```

* 函数名本身就是地址：`add == &add`
* 数组名与函数名不同：

  * `arr == &arr[0]` （数组名退化为首元素指针）
  * `&arr` 是整个数组地址，类型不同

---

## 2-函数指针-核心价值

> 把函数当作数据传递，使程序更灵活、可扩展、可复用

* 主要用途：

  1. 回调函数（Callback）
  2. 函数数组 / 菜单调用
  3. 状态机（State Machine）
  4. 结构体 + 函数指针 → 模拟虚函数 / 多态
  5. 拓展场景：插件机制、事件驱动、算法可替换、任务调度

---

## 3-应用示例与说明

### 3-1-回调函数callback

* 概念：把行为传给另一个函数，让它在内部调用
* 示例：排序函数中传入不同比较规则

```c
int cmp_asc(int a,int b){ return a > b; }
int cmp_desc(int a,int b){ return a < b; }

void bubble_sort(int arr[], int n, int (*cmp)(int,int)){
    for(int i=0;i<n-1;i++){
        for(int j=0;j<n-1-i;j++){
            if(cmp(arr[j],arr[j+1])){
                int t=arr[j]; arr[j]=arr[j+1]; arr[j+1]=t;
            }
        }
    }
}
```

* 优点：

  * 动态传递行为
  * 减少重复代码
  * 提高灵活性
* 不用函数指针的替代方法：

```c
void bubble_sort(int arr[], int n, const char* order) {
    for(int i=0;i<n-1;i++){
        for(int j=0;j<n-1-i;j++){
            if((strcmp(order,"asc")==0 && arr[j]>arr[j+1]) ||
               (strcmp(order,"desc")==0 && arr[j]<arr[j+1])){
                int t=arr[j]; arr[j]=arr[j+1]; arr[j+1]=t;
            }
        }
    }
}
```

* 优点：简单，易理解
* 缺点：判断开销、扩展性差

---

### 3-2-函数数组-菜单调用

* 概念：把多个函数地址存入数组，根据索引调用

```c
void say_hello() { printf("Hello!\n"); }
void say_bye()   { printf("Bye!\n"); }

void (*actions[2])() = {say_hello, say_bye};

int choice;
scanf("%d",&choice);
if(choice>=0 && choice<2) actions[choice]();
```

* 优点：

  * 减少 if/else 或 switch
  * 扩展功能简单

* 行为可动态选择

* 不用函数指针的替代方法：

```c
if(choice==0) say_hello();
else if(choice==1) say_bye();
```

* 优点：简单直接
* 缺点：分支多时不易扩展，可读性差

---

### 3-3-状态机state-machine

* 概念：每个状态对应一个函数指针

```c
void red()    { printf("红灯亮\n"); }
void green()  { printf("绿灯亮\n"); }
void yellow() { printf("黄灯亮\n"); }

void (*state)() = red;
state();       // 红灯
state = green;
state();       // 绿灯
```

* 优点：

  * 状态切换直观
  * 减少条件判断
  * 易扩展
* 不用函数指针的替代方法：

```c
if(state==RED) red();
else if(state==GREEN) green();
else if(state==YELLOW) yellow();
```

---

### 3-4-结构体-函数指针-模拟虚函数

```c
typedef struct { void (*speak)(); } Animal;
void dog_speak() { printf("汪汪汪\n"); }
void cat_speak() { printf("喵喵喵\n"); }

Animal dog = {dog_speak};
Animal cat = {cat_speak};

dog.speak();
cat.speak();
```

* 优点：

  * 实现多态
  * 统一接口，不同实现
  * 方便大型工程扩展
* 不用函数指针的替代方法：

  * 每种动物写单独函数调用，没有统一接口
  * 缺点：增加对象类型时需要改调用代码，扩展性差

---

## 4-拓展场景

* 插件机制 / 动态加载
* 事件驱动系统（GUI、网络）
* 函数指针数组 + 循环表（任务调度、定时器）
* 算法可替换（排序、搜索、压缩、加密等）

---

## 5-函数指针-总结

* 核心作用：把函数当作数据传递，让程序更灵活、可扩展、可复用
* 什么时候用：

  * 行为需要动态选择
  * 统一接口，不同实现
  * 提高扩展性和可复用性
* 思路：把函数名当作“指针”，可以存储、传递、动态调用
* 不用函数指针时：

  * 条件判断简单直接，但扩展性差、代码重复多、效率稍低

---

